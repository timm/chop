#!/usr/bin/env bash
# vim: ft=awk ts=2 sw=2 et :
gold() { 
  gawk -f gold.awk --source '{transpile($0)}' > /tmp/$$.awk
  gawk -f gold.awk -f  /tmp/$$.awk
}
cat<<`EOF` | gold 

BEGIN { 
  The.some.max = 256 
  The.ch.skip = "?" 
  The.stats.cliff = "?" 
}

function add(i,x) { 
  if (x != The.ch.skip)  { i.n++; add1(i,x) }
  return x
}
function add1(i,x,   f) {f=i.isa "_add1"; return @f(i.x) }

function Sym(i) {
  isa(i,"Sym")
  has(i,seen)
  i.mode = i.most = ""
}
function _add1(i,x) {
  i.seen[x] = i.seen[x] + 1
  if (i.seen[x] > i.most) { i.most=i.seen[x]; i.mode=x}
}
function _score(i,goal,all,     
                  e,y,n,yall,nall,ys,ns,tmp) {
  e    = 0.00001
  y    = i.seen[goal]
  n    = i.n - y
  yall = all.seen[goal] 
  nall = all.n - yall
  ys   = y    / (e+ yall)
  ns   = n    / (e+ nall)
  tmp  = ys**2 / (e+ ys + ns)
  return (i.score = tmp > 0.01 ? tmp : 0)
}
function Num(i) {
  isa(i,"Num")
  i.hi=-10**32
  i.lo=10**32
  has(i,"Some")
}
function _add1(i, x) {
  add(i.some,x)
  i.hi = max(i.hi,x)
  i.lo = min(i.lo,x)
}

### Some(i:list0,max:pos) :nil
## Constructor for `Some` objects that keep a random sample of atoms.
## - `i.n` is now many things were set to this `Some`
## - `i.all` is all the fhings kept (may be less that `i.n`
## - `i.max` is the maximum number of things kept (and if we keep more
##   than that, then order things (selected at random) will be removed.
## - `i.ok` is false when `i.all` has been updated, but not resorted yet.
function Some(i, max) {
  isa(i,"Some")
  i.n=0
  has(i,"all")
  i.ok=1          # if 0, then `i.all` needs resoting
  i.max = max ? max : The.some.max
}
function _update(i,x,k) { 
  i.all[k]=x; i.ok=0 
}
function _add1(i,x, j) {
  if (length(i.all)  < i.max) 
    _update(i, x, length(i.all) + 1)
  else if (rand() < i.max/i.n) 
    _update(i, x, int(0.5+length(i.all)*rand()))
}
function _ok(i) {
  if (!i.ok) i.ok= asort(i.all) 
}
function _few(i,few,   j,k) {
  _ok(i)
  k = max(1, int(0.5+ length(i)/ The.some.max))
  for(j=1; j<=length(i.all); j += k) 
    push( i.all[j], few) 
}
function _same(i,j,   ai,aj) {
  _few(i, ai)
  _few(j, aj)
  return cliffs(ai,aj)
}
function Rows(i) {
  List(i)
  has(i,"names")
  has(i,"uses")
  has(i,"rows")
  has(i,"cols")
}
function num(s) { return s ~/[:<>]/ }
function y(s)   { return s ~/[!<>]/ }
function x(s)   { return not y(s) }
function sym(s) { return not num(s) }
function want(nn,out,want1,want2) {
  for(i in nn)
    if (@want1(N[i]) ||  want2 && @want2(N[i])
      out[i] = i
}
function using(u, get,  put,o) {
  for(i in get
    if($get !~ /\?/) 
      u[get] = ++put
}
function reads(
function reads(a,Use,Names,Cols,Rows) { 
  if length(Use)
    readRow(a,C,R,U,N)


function cliffs(as,bs,t,    a,b,n,lt,gt) {
  t= t? t : The.stats.cliff
  for(a in as)
   for(b in bs) {
     n++
     if (as[a] < bs[b]) lt++
     if (as[a] > bs[b]) gt++
  }
  return abs(lt-gt)/n < t
}

BEGIN { rogues() }
